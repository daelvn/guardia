{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gu\u00e0rdia 3 - Function guards for Lua & MoonScript \u00b6 Gu\u00e0rdia is a small library in hopes of obsoleting guard.lua , which is pretty old already if you ask me. This one, to nobody's surprise, is curried and focused on MoonScript, but hey, you're stil free to use it in Lua. Installation \u00b6 $ luarocks install guardia You can also use the library manually by just downloading the guardia folder, but that's gross. License \u00b6 I'm throwing this, as always, to the public domain, do what you want with it. Maintainer \u00b6 Dael [daelvn@gmail.com] Goodbye? \u00b6 goodbye.","title":"Home"},{"location":"#guardia-3-function-guards-for-lua-moonscript","text":"Gu\u00e0rdia is a small library in hopes of obsoleting guard.lua , which is pretty old already if you ask me. This one, to nobody's surprise, is curried and focused on MoonScript, but hey, you're stil free to use it in Lua.","title":"Gu\u00e0rdia 3 - Function guards for Lua &amp; MoonScript"},{"location":"#installation","text":"$ luarocks install guardia You can also use the library manually by just downloading the guardia folder, but that's gross.","title":"Installation"},{"location":"#license","text":"I'm throwing this, as always, to the public domain, do what you want with it.","title":"License"},{"location":"#maintainer","text":"Dael [daelvn@gmail.com]","title":"Maintainer"},{"location":"#goodbye","text":"goodbye.","title":"Goodbye?"},{"location":"changelog/","text":"Changelog \u00b6 v3.0 \u00b6 Removed examples folder. Removed v2 tests. guardia . v2 becomes simply guardia . _type from guardia . guards does not negate the result anymore. This increases clearness. Added logical operators in guardia . init . Added manual. Changed the behavior of _type as explained in the Guards Manual . _utype and _utable are not exported anymore. Removed doc comments from source code.","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#v30","text":"Removed examples folder. Removed v2 tests. guardia . v2 becomes simply guardia . _type from guardia . guards does not negate the result anymore. This increases clearness. Added logical operators in guardia . init . Added manual. Changed the behavior of _type as explained in the Guards Manual . _utype and _utable are not exported anymore. Removed doc comments from source code.","title":"v3.0"},{"location":"examples/core/","text":"Source code for Core Manual \u00b6 Simple type checking using Gu\u00e0rdia.","title":"core.moon"},{"location":"examples/core/#source-code-for-core-manual","text":"Simple type checking using Gu\u00e0rdia.","title":"Source code for Core Manual"},{"location":"examples/simple-type-checking/","text":"Simple type checking \u00b6 Simple type checking using Gu\u00e0rdia.","title":"simple-type-checking.moon"},{"location":"examples/simple-type-checking/#simple-type-checking","text":"Simple type checking using Gu\u00e0rdia.","title":"Simple type checking"},{"location":"manual/core/","text":"Gu\u00e0rdia Core Manual \u00b6 This is something like a tutorial for Gu\u00e0rdia 3. This should give you a basic understanding of how the library works and how to use it properly. Chains \u00b6 Gu\u00e0rdia works in chains, that take in any amount of arguments, transform or filter them in some way, and then return another set of arguments. You can think of it as piping in shells. Each chain starts with a Source , continues with a Transformer and ends with a Finalizer . All kinds are interchangeable between them when all sources are applied (you can use _filter and _true in the same place). Boolean chains \u00b6 The chains that functions in guardia . init deal with always starts and end with a given set of arguments, but in the middle of the chain, the first element passed/returned is a boolean, dubbed state . Therefore, you could make a text diagram of a chain as ... \u2192 boolean , ... \u2192 ... . Complex chains \u00b6 Complex chains (specified in modules such as guardia . trace ) will still start and end with a given set of arguments, but the elements passed and returned may not necessarily be boolean , ... , unlike boolean chains. They may be boolean , string , ... or even function , ... , depending on the module. These are less common and are usually specialized. Chain lifters exist, that are able to convert a common chain into a complex chain (and sometimes the other way). Building a simple chain \u00b6 Getting started \u00b6 To begin with, we're going to build a simple boolean chain. Open up your favourite REPL and import guardia . MoonScript > g = require \" guardia \" Lua > g = require ( \"guardia\" ) The simplest chain we can come up with, but also the most useless, would be one that just starts and ends. MoonScript > g . _finalize g . _true 5 , 6 5 , 6 Lua > g . _finalize ( g . _true ( 5 , 6 )) 5 , 6 _true just starts a boolean chain where the state is true , and passes the same arguments we passed, 5 and 6 . Then _finalize gets rid of the state, just to return the arguments. Right now, the state is irrelevant, which means we could also write our example as g . _finalize g . _false 5 , 6 and it would return the same. Chains can get long, so Gu\u00e0rdia provides aliases for each function, which would let us rewrite it as g . _fn g . _t 5 , 6 or g . _fn g . _f 5 , 6 . Note Usually, we would only import the functions we need and get rid of g , but since we are on the REPL, we'll leave it. If we wanted to look at what's going in between _finalize and _true , we would see true , 5 , 6 , and we actually can do that, using _inspect , which aliases to _in . It just prints whatever it gets passed, and also returns it. Think of it as tee for Gu\u00e0rdia. MoonScript > g . _fn g . _in g . _t 5 , 6 1 true 5 6 5 , 6 Lua > g . _fn ( g . _in ( g . _t ( 5 , 6 )))) 1 true 5 6 5 , 6 We might see a number we don't recognize, 1 , that is. Gu\u00e0rdia keeps track of the times that the function has been called, so you can keep track of the order of inspections more easily. If you wanted you get fancy, you can replace the count with your own string, by using the _named ( _ci , for c omplex i nspect) function. It first takes a string, and returns a function that acts exactly like _inspect , but always prints the string instead. MoonScript > g . _fn ( g . _ci \" hewwo \" ) g . _t 5 , 6 hewwo true 5 6 5 , 6 Lua > g . _fn ( g . _ci ( \"hewwo\" )( g . _t ( 5 , 6 ))) hewwo true 5 6 5 , 6 Getting spicy \u00b6 But obviously, we will want to do something with our chain, so let's start with using it for simple checks with the _filter ( _fl ) function. It takes a function, and then returns a source that will run the function with the arguments passed to it. This is better explained by looking at the actual source. MoonScript _filter = ( fl ) -> ( ... ) -> if fl ... then true , ... else false , ... Lua local _filter = function ( fl ) return function (...) if fl (...) then return true , ... else return false , ... end end end If fl (...) is truthy, then the chain will start with true , ... , otherwise with false , ... . We can use it with functions such as: MoonScript is5 = ( x ) -> x == 5 Lua local function is5 ( x ) return x == 5 end And then use it with filter this way: MoonScript > g . _fn ( g . _fl is5 ) 5 , 6 5 , 6 Lua > g . _fn (( g . _fl is5 )( 5 , 6 )) 5 , 6 If we were to inspect what was going on in the middle, we would see that the function returns true . But why is it not checking the 6? Well, we only setup our function to take a single argument, so we could modify it to work for any number of arguments: MoonScript is5 = ( ... ) -> args , status = { ... } , true for arg in * args status = false if arg != 5 return status Lua local function is5 (...) local args , status = {...}, true for i , arg in ipairs ( arguments ) do if arg ~= 5 then status = false end end return status end And that would still work. But, what is the point if we are still getting 5 and 6? Well, there is a finalizer named _status ( _st ) that returns the status of the boolean chain, dropping the values. MoonScript > g . _st ( g . _fl is5 ) 5 , 5 true > g . _st ( g . _fl is5 ) 5 , 6 false Lua > g . _st (( g . _fl is5 )( 5 , 5 )) true > g . _st (( g . _fl is5 )( 5 , 6 )) false If you need to negate the result of a source, or just negate the status anywhere in a chain, you would use _negate (alias _ng ). MoonScript > g . _st g . _ng ( g . _fl is5 ) 5 , 5 false Lua > g . _st ( g . _ng ( g . _fl ( is5 )( 5 , 5 ))) false Getting useful \u00b6 But wait, isn't this essentially the same than running is5 5 , 6 ? Well yes, it is, but is5 does not compose, and we are not really doing anything with the information. We have to do something with it, this is when the concept of Transformers comes in. It's nothing new, you've actually already seen it: _negate , _inspect and _named all fit into the concept of transformers. They're just functions that get a chain and return another chain. The most important one would possibly be _transform ( _tr ), which takes a function, and then, depending on the status of the function, runs the transformer or not. This is its source: MoonScript _transform = ( tr ) -> ( b , ... ) -> if b then true , tr ... else false , ... Lua local _transform = function ( tr ) return function ( b , ...) if b then return true , tr (...) else return false , ... end end end So let's make a function that, say, changes all arguments to 3s. MoonScript to3 = ( ... ) -> args = { ... } return table.unpack for i = 1 , # args do 3 -- for those unfamiliar with MoonScript syntax, this essentially creates a table of length #args that only -- contains 3s, and then unpacks it and returns all the 3s individually. Lua local function to3 (...) local args , t = {...}, {} for i = 1 , # args do table.insert ( t , 3 ) end return table.unpack ( t ) end However, if we were to include this in our chain, it would change all of them indiscriminately: MoonScript > g . _fn ( g . _tr to3 ) g . _t 5 , true , \" a \" 3 , 3 , 3 Lua > g . _fn ( g . _tr ( to3 )( g . _t ( 5 , true , \"a\" ))) 3 , 3 , 3 We probably would want to change all of them only when they meet a certain condition. We can do that with filters! Let's use our is5 filter. We know that _transform only runs the function when the boolean chain status is true, and _filter precisely sets the status for a chain, so let's combine those together: MoonScript > g . _fn ( g . _tr to3 ) ( g . _fl is5 ) 5 , true , \" a \" 5 , true , \" a \" > g . _fn ( g . _tr to3 ) ( g . _fl is5 ) 5 , 5 , 5 3 , 3 , 3 Lua > g . _fn (( g . _tr ( to3 ))(( g . _fl ( is5 ))( 5 , true , \"a\" ))) 5 , true , \"a\" > g . _fn (( g . _tr ( to3 ))(( g . _fl ( is5 ))( 5 , 5 , 5 ))) 3 , 3 , 3 It works! This is essentially all you need to build type checkers, so very simple functions can build something bigger. Getting nasty \u00b6 Let's say we actually want to build a type checker. Just check that our function is getting a certain argument of a certain type, decorator-style. First, we would build a filter to check we're getting the type we want. Let's check for numbers. MoonScript _number = g . _fl ( x ) -> ( type x ) == \" number \" -- Mind the use of _fl! Lua local _number = g . _fl ( function ( x ) return type ( x ) == \"number\" end ) -- Mind the use of _fl! Tip _number is a guardia . guards builtin, and it also automatically checks for a __type metafield in tables, so you should probably use that instead of building them yourself. They're also automatically generated, which means that importing _Nice from the guards module will create a type checker that checks for the type Nice . Warning The _number function we built is only asking for one argument! Keep this in mind when reading and trying examples, and feel free to import _number from require \"guardia.guards\" if you need to use more arguments. Now, that's very fine and all, but what do we do if we're not getting a number? We can use _error ( _er ), that will let us raise an error when something that we don't want to happen, happens. Let's define one: > _e_notnumber = g . _er \" That's not a number! \" Note It is a general convention to define errors as _e_NAME , so when people see them in chains, they know that is an error. If we didn't want to write our own error message, you can always use the _e1 builtin, which is essentially _er but it errors with \"guardia $ chain was stopped\" , in case you want to do quick debugging. The error will be raised if the status on the chain is true. Sounds about right, except our filter will return true on numbers! We don't want to error when we get a number! We will simply use _negate . We build our chain like this: > g . _fn _e_notnumber g . _ng _number 5 5 In the case that we don't pass numbers, it will error. We will expand on how to catch those later. Getting a burrito \u00b6 Yeah yeah the last thing was very fun, but how do I use it with my function? Your first thought might be to just precede the arguments with it: myFunction g . _fn _e_notnumber g . _ng _number 5 But not everyone is going to want to write all that when calling your functions, they expect your function to be already checking for types. This is where we come up with a really simply solution, which is wrapping. _myFunction = => ( ... ) -> @ g . _fn _e_notnumber g . _ng _number ... -- this could also be written as _myFunction = ( f ) -> ( ... ) -> f g . _fn _e_notnumber g . _ng _number ... Note It is also kind of a convention to define your wrappers as _functionName , and they should be defined right above your function definition, kind of like a type signature. Kind of . Now, every function we pass to _myFunction will get its first argument typechecked, and will error if it is not an argument, we may now define our function as: myFunction = _myFunction ( x ) -> x Getting logical \u00b6 Now, what do we do if we want to check for several conditions as a source? Gu\u00e0rdia provides the builtins _or , _and and _xor (and their uncurried counterparts, _or1 , _and1 and _xor1 ) that ask for two filters, and return the unified filter. Say we had a filter equivalent to is5 , but for 4s ( is4 ), we could logically OR them this way: _is4or5 = g . _or1 ( g . _fl is4 ) , ( g . _fl is5 ) Tip Most of the time we are inlining chains, so for clarity, you might want to use the uncurried version of the logical operators instead of the curried ones. Getting safe \u00b6 We usually want to check for nil in our arguments, and replace it with something else otherwise: a default value. Gu\u00e0rdia provides a builtin for this named _default ( _df ), which only works for the first argument but is good enough for curried functions. It is basically a wrapper for _transform and _filter with a nil type checker embedded, and is indeed a source: > g . _fn ( g . _df 5 ) nil 5 Getting double \u00b6 Now, we have only done chains with a single transformation and a single filter, but what if we need more? It is as simple to use _pass (alias _ps ), which discards the status mid-chain and lets you use a filter right after it. Note _pass is equivalent to _finalize , in fact, _finalize and _fn are just aliases for _pass , but they're that way so that it is clearer in a chain, but feel free to use only _pass or only _finalize , they're the same function, they're interchangeable. > g . _fn ( g . _tr to3 ) ( g . _fl arg1is5 ) g . _ps ( g . _tr to4 ) ( g . _fl arg1is6 ) 5 , 7 , 9 3 , 3 , 3 (Yes, I know we didn't define many of these functions, but I hope you understand what they do by their name) Wrapping up \u00b6 That is essentially everything in the core library, which doesn't cover the guards library nor others. But it will do for most cases.","title":"Core"},{"location":"manual/core/#guardia-core-manual","text":"This is something like a tutorial for Gu\u00e0rdia 3. This should give you a basic understanding of how the library works and how to use it properly.","title":"Gu\u00e0rdia Core Manual"},{"location":"manual/core/#chains","text":"Gu\u00e0rdia works in chains, that take in any amount of arguments, transform or filter them in some way, and then return another set of arguments. You can think of it as piping in shells. Each chain starts with a Source , continues with a Transformer and ends with a Finalizer . All kinds are interchangeable between them when all sources are applied (you can use _filter and _true in the same place).","title":"Chains"},{"location":"manual/core/#boolean-chains","text":"The chains that functions in guardia . init deal with always starts and end with a given set of arguments, but in the middle of the chain, the first element passed/returned is a boolean, dubbed state . Therefore, you could make a text diagram of a chain as ... \u2192 boolean , ... \u2192 ... .","title":"Boolean chains"},{"location":"manual/core/#complex-chains","text":"Complex chains (specified in modules such as guardia . trace ) will still start and end with a given set of arguments, but the elements passed and returned may not necessarily be boolean , ... , unlike boolean chains. They may be boolean , string , ... or even function , ... , depending on the module. These are less common and are usually specialized. Chain lifters exist, that are able to convert a common chain into a complex chain (and sometimes the other way).","title":"Complex chains"},{"location":"manual/core/#building-a-simple-chain","text":"","title":"Building a simple chain"},{"location":"manual/core/#getting-started","text":"To begin with, we're going to build a simple boolean chain. Open up your favourite REPL and import guardia . MoonScript > g = require \" guardia \" Lua > g = require ( \"guardia\" ) The simplest chain we can come up with, but also the most useless, would be one that just starts and ends. MoonScript > g . _finalize g . _true 5 , 6 5 , 6 Lua > g . _finalize ( g . _true ( 5 , 6 )) 5 , 6 _true just starts a boolean chain where the state is true , and passes the same arguments we passed, 5 and 6 . Then _finalize gets rid of the state, just to return the arguments. Right now, the state is irrelevant, which means we could also write our example as g . _finalize g . _false 5 , 6 and it would return the same. Chains can get long, so Gu\u00e0rdia provides aliases for each function, which would let us rewrite it as g . _fn g . _t 5 , 6 or g . _fn g . _f 5 , 6 . Note Usually, we would only import the functions we need and get rid of g , but since we are on the REPL, we'll leave it. If we wanted to look at what's going in between _finalize and _true , we would see true , 5 , 6 , and we actually can do that, using _inspect , which aliases to _in . It just prints whatever it gets passed, and also returns it. Think of it as tee for Gu\u00e0rdia. MoonScript > g . _fn g . _in g . _t 5 , 6 1 true 5 6 5 , 6 Lua > g . _fn ( g . _in ( g . _t ( 5 , 6 )))) 1 true 5 6 5 , 6 We might see a number we don't recognize, 1 , that is. Gu\u00e0rdia keeps track of the times that the function has been called, so you can keep track of the order of inspections more easily. If you wanted you get fancy, you can replace the count with your own string, by using the _named ( _ci , for c omplex i nspect) function. It first takes a string, and returns a function that acts exactly like _inspect , but always prints the string instead. MoonScript > g . _fn ( g . _ci \" hewwo \" ) g . _t 5 , 6 hewwo true 5 6 5 , 6 Lua > g . _fn ( g . _ci ( \"hewwo\" )( g . _t ( 5 , 6 ))) hewwo true 5 6 5 , 6","title":"Getting started"},{"location":"manual/core/#getting-spicy","text":"But obviously, we will want to do something with our chain, so let's start with using it for simple checks with the _filter ( _fl ) function. It takes a function, and then returns a source that will run the function with the arguments passed to it. This is better explained by looking at the actual source. MoonScript _filter = ( fl ) -> ( ... ) -> if fl ... then true , ... else false , ... Lua local _filter = function ( fl ) return function (...) if fl (...) then return true , ... else return false , ... end end end If fl (...) is truthy, then the chain will start with true , ... , otherwise with false , ... . We can use it with functions such as: MoonScript is5 = ( x ) -> x == 5 Lua local function is5 ( x ) return x == 5 end And then use it with filter this way: MoonScript > g . _fn ( g . _fl is5 ) 5 , 6 5 , 6 Lua > g . _fn (( g . _fl is5 )( 5 , 6 )) 5 , 6 If we were to inspect what was going on in the middle, we would see that the function returns true . But why is it not checking the 6? Well, we only setup our function to take a single argument, so we could modify it to work for any number of arguments: MoonScript is5 = ( ... ) -> args , status = { ... } , true for arg in * args status = false if arg != 5 return status Lua local function is5 (...) local args , status = {...}, true for i , arg in ipairs ( arguments ) do if arg ~= 5 then status = false end end return status end And that would still work. But, what is the point if we are still getting 5 and 6? Well, there is a finalizer named _status ( _st ) that returns the status of the boolean chain, dropping the values. MoonScript > g . _st ( g . _fl is5 ) 5 , 5 true > g . _st ( g . _fl is5 ) 5 , 6 false Lua > g . _st (( g . _fl is5 )( 5 , 5 )) true > g . _st (( g . _fl is5 )( 5 , 6 )) false If you need to negate the result of a source, or just negate the status anywhere in a chain, you would use _negate (alias _ng ). MoonScript > g . _st g . _ng ( g . _fl is5 ) 5 , 5 false Lua > g . _st ( g . _ng ( g . _fl ( is5 )( 5 , 5 ))) false","title":"Getting spicy"},{"location":"manual/core/#getting-useful","text":"But wait, isn't this essentially the same than running is5 5 , 6 ? Well yes, it is, but is5 does not compose, and we are not really doing anything with the information. We have to do something with it, this is when the concept of Transformers comes in. It's nothing new, you've actually already seen it: _negate , _inspect and _named all fit into the concept of transformers. They're just functions that get a chain and return another chain. The most important one would possibly be _transform ( _tr ), which takes a function, and then, depending on the status of the function, runs the transformer or not. This is its source: MoonScript _transform = ( tr ) -> ( b , ... ) -> if b then true , tr ... else false , ... Lua local _transform = function ( tr ) return function ( b , ...) if b then return true , tr (...) else return false , ... end end end So let's make a function that, say, changes all arguments to 3s. MoonScript to3 = ( ... ) -> args = { ... } return table.unpack for i = 1 , # args do 3 -- for those unfamiliar with MoonScript syntax, this essentially creates a table of length #args that only -- contains 3s, and then unpacks it and returns all the 3s individually. Lua local function to3 (...) local args , t = {...}, {} for i = 1 , # args do table.insert ( t , 3 ) end return table.unpack ( t ) end However, if we were to include this in our chain, it would change all of them indiscriminately: MoonScript > g . _fn ( g . _tr to3 ) g . _t 5 , true , \" a \" 3 , 3 , 3 Lua > g . _fn ( g . _tr ( to3 )( g . _t ( 5 , true , \"a\" ))) 3 , 3 , 3 We probably would want to change all of them only when they meet a certain condition. We can do that with filters! Let's use our is5 filter. We know that _transform only runs the function when the boolean chain status is true, and _filter precisely sets the status for a chain, so let's combine those together: MoonScript > g . _fn ( g . _tr to3 ) ( g . _fl is5 ) 5 , true , \" a \" 5 , true , \" a \" > g . _fn ( g . _tr to3 ) ( g . _fl is5 ) 5 , 5 , 5 3 , 3 , 3 Lua > g . _fn (( g . _tr ( to3 ))(( g . _fl ( is5 ))( 5 , true , \"a\" ))) 5 , true , \"a\" > g . _fn (( g . _tr ( to3 ))(( g . _fl ( is5 ))( 5 , 5 , 5 ))) 3 , 3 , 3 It works! This is essentially all you need to build type checkers, so very simple functions can build something bigger.","title":"Getting useful"},{"location":"manual/core/#getting-nasty","text":"Let's say we actually want to build a type checker. Just check that our function is getting a certain argument of a certain type, decorator-style. First, we would build a filter to check we're getting the type we want. Let's check for numbers. MoonScript _number = g . _fl ( x ) -> ( type x ) == \" number \" -- Mind the use of _fl! Lua local _number = g . _fl ( function ( x ) return type ( x ) == \"number\" end ) -- Mind the use of _fl! Tip _number is a guardia . guards builtin, and it also automatically checks for a __type metafield in tables, so you should probably use that instead of building them yourself. They're also automatically generated, which means that importing _Nice from the guards module will create a type checker that checks for the type Nice . Warning The _number function we built is only asking for one argument! Keep this in mind when reading and trying examples, and feel free to import _number from require \"guardia.guards\" if you need to use more arguments. Now, that's very fine and all, but what do we do if we're not getting a number? We can use _error ( _er ), that will let us raise an error when something that we don't want to happen, happens. Let's define one: > _e_notnumber = g . _er \" That's not a number! \" Note It is a general convention to define errors as _e_NAME , so when people see them in chains, they know that is an error. If we didn't want to write our own error message, you can always use the _e1 builtin, which is essentially _er but it errors with \"guardia $ chain was stopped\" , in case you want to do quick debugging. The error will be raised if the status on the chain is true. Sounds about right, except our filter will return true on numbers! We don't want to error when we get a number! We will simply use _negate . We build our chain like this: > g . _fn _e_notnumber g . _ng _number 5 5 In the case that we don't pass numbers, it will error. We will expand on how to catch those later.","title":"Getting nasty"},{"location":"manual/core/#getting-a-burrito","text":"Yeah yeah the last thing was very fun, but how do I use it with my function? Your first thought might be to just precede the arguments with it: myFunction g . _fn _e_notnumber g . _ng _number 5 But not everyone is going to want to write all that when calling your functions, they expect your function to be already checking for types. This is where we come up with a really simply solution, which is wrapping. _myFunction = => ( ... ) -> @ g . _fn _e_notnumber g . _ng _number ... -- this could also be written as _myFunction = ( f ) -> ( ... ) -> f g . _fn _e_notnumber g . _ng _number ... Note It is also kind of a convention to define your wrappers as _functionName , and they should be defined right above your function definition, kind of like a type signature. Kind of . Now, every function we pass to _myFunction will get its first argument typechecked, and will error if it is not an argument, we may now define our function as: myFunction = _myFunction ( x ) -> x","title":"Getting a burrito"},{"location":"manual/core/#getting-logical","text":"Now, what do we do if we want to check for several conditions as a source? Gu\u00e0rdia provides the builtins _or , _and and _xor (and their uncurried counterparts, _or1 , _and1 and _xor1 ) that ask for two filters, and return the unified filter. Say we had a filter equivalent to is5 , but for 4s ( is4 ), we could logically OR them this way: _is4or5 = g . _or1 ( g . _fl is4 ) , ( g . _fl is5 ) Tip Most of the time we are inlining chains, so for clarity, you might want to use the uncurried version of the logical operators instead of the curried ones.","title":"Getting logical"},{"location":"manual/core/#getting-safe","text":"We usually want to check for nil in our arguments, and replace it with something else otherwise: a default value. Gu\u00e0rdia provides a builtin for this named _default ( _df ), which only works for the first argument but is good enough for curried functions. It is basically a wrapper for _transform and _filter with a nil type checker embedded, and is indeed a source: > g . _fn ( g . _df 5 ) nil 5","title":"Getting safe"},{"location":"manual/core/#getting-double","text":"Now, we have only done chains with a single transformation and a single filter, but what if we need more? It is as simple to use _pass (alias _ps ), which discards the status mid-chain and lets you use a filter right after it. Note _pass is equivalent to _finalize , in fact, _finalize and _fn are just aliases for _pass , but they're that way so that it is clearer in a chain, but feel free to use only _pass or only _finalize , they're the same function, they're interchangeable. > g . _fn ( g . _tr to3 ) ( g . _fl arg1is5 ) g . _ps ( g . _tr to4 ) ( g . _fl arg1is6 ) 5 , 7 , 9 3 , 3 , 3 (Yes, I know we didn't define many of these functions, but I hope you understand what they do by their name)","title":"Getting double"},{"location":"manual/core/#wrapping-up","text":"That is essentially everything in the core library, which doesn't cover the guards library nor others. But it will do for most cases.","title":"Wrapping up"},{"location":"manual/guards/","text":"Gu\u00e0rdia Guards Manual \u00b6 This is a shorter tutorial oriented to understanding guardia.guards which is a pretty small module for type checking. If you are new to Gu\u00e0rdia, you should read the Core Manual first. Type checking \u00b6 General \u00b6 Normal type checking is done using the _type function, which takes a type name and a type function (that defaults to Lua's type ). Then it returns a Source that will take any number of arguments and check that they all are of the same type, the one you passed. Since it is a Source, it needs to be finalized using _fn or similar. MoonScript -- check that we are getting a string, error otherwise _e_notstring = _er \" Didn't get a string! \" _string = _type \" string \" fun _fn _e_notstring _ng _string ... Lua -- check that we are getting a string, error otherwise local _e_notstring = _er ( \"Didn't get a string!\" ) local _string = _type ( \"string\" ) fun ( _fn ( _e_notstring ( _ng ( _string (...))))) Tables \u00b6 You can check that a table has elements all of the same type by using the _tableof function, and it works similarly to _type , also taking a type function optionally. It works with multiple tables, and if any of the arguments is not a table, then false will be returned. Custom type checking \u00b6 The purpose of having an optional argument for the type function is to provide compatibility with libraries such as lua-typical or the always-unreleased ltypekit . However, and regardless of the type function used, if a Lua table contains a __type metafield that is a function or a string, it will be used (mimicking lua - typical behavior, if you wish to disable this, pass NO_TYPICAL as the type function.) Automatic type checker generator \u00b6 This module lets you import type checkers dynamically so you don't have to define them yourself, so importing _MyType from the module will give you a checker for the type \"MyType\", and importing _not_MyType will check for anything but \"MyType\". MoonScript import _MyType from require \" guardia.guards \" _MyType setmetatable {} , { __type: \" MyType \" } -- true, {}:MyType Lua local _MyType = require \"guardia.guards\" . _MyType _MyType ( setmetatable ({},{ __type = \"MyType\" })) -- true, {}:MyType","title":"Guards"},{"location":"manual/guards/#guardia-guards-manual","text":"This is a shorter tutorial oriented to understanding guardia.guards which is a pretty small module for type checking. If you are new to Gu\u00e0rdia, you should read the Core Manual first.","title":"Gu\u00e0rdia Guards Manual"},{"location":"manual/guards/#type-checking","text":"","title":"Type checking"},{"location":"manual/guards/#general","text":"Normal type checking is done using the _type function, which takes a type name and a type function (that defaults to Lua's type ). Then it returns a Source that will take any number of arguments and check that they all are of the same type, the one you passed. Since it is a Source, it needs to be finalized using _fn or similar. MoonScript -- check that we are getting a string, error otherwise _e_notstring = _er \" Didn't get a string! \" _string = _type \" string \" fun _fn _e_notstring _ng _string ... Lua -- check that we are getting a string, error otherwise local _e_notstring = _er ( \"Didn't get a string!\" ) local _string = _type ( \"string\" ) fun ( _fn ( _e_notstring ( _ng ( _string (...)))))","title":"General"},{"location":"manual/guards/#tables","text":"You can check that a table has elements all of the same type by using the _tableof function, and it works similarly to _type , also taking a type function optionally. It works with multiple tables, and if any of the arguments is not a table, then false will be returned.","title":"Tables"},{"location":"manual/guards/#custom-type-checking","text":"The purpose of having an optional argument for the type function is to provide compatibility with libraries such as lua-typical or the always-unreleased ltypekit . However, and regardless of the type function used, if a Lua table contains a __type metafield that is a function or a string, it will be used (mimicking lua - typical behavior, if you wish to disable this, pass NO_TYPICAL as the type function.)","title":"Custom type checking"},{"location":"manual/guards/#automatic-type-checker-generator","text":"This module lets you import type checkers dynamically so you don't have to define them yourself, so importing _MyType from the module will give you a checker for the type \"MyType\", and importing _not_MyType will check for anything but \"MyType\". MoonScript import _MyType from require \" guardia.guards \" _MyType setmetatable {} , { __type: \" MyType \" } -- true, {}:MyType Lua local _MyType = require \"guardia.guards\" . _MyType _MyType ( setmetatable ({},{ __type = \"MyType\" })) -- true, {}:MyType","title":"Automatic type checker generator"},{"location":"module/guardia.guards/","text":"guardia.guards \u00b6 Set of guards that come with Gu\u00e0rdia. Batteries included! Importing _ < type > from this module will return a type guard for < type > . Importing _not_ < type > from this module will return a negated type guard for < type > . _type \u00b6 Signature \u2192 ( string , [ function ] ) -> (...) -> boolean , ... Type-checking source guard. Has to be manually finalized with _ps . _tableof \u00b6 Signature \u2192 ( string , [ function ] ) -> (...) -> boolean , ... Guard that checks that all elements of a table are of the same type. _tostring \u00b6 Signature \u2192 ( boolean , ...) -> -> boolean , ... tostring transformer guard. Warn Since it uses native tostring as the transformer function, it only supports conversion of one argument, so you would need a function that runs tostring on every argument passed. _tonumber \u00b6 Signature \u2192 ( boolean , ...) -> -> boolean , ... tonumber transformer guard. Warn Since it uses native tonumber as the transformer function, it only supports conversion of one argument, so you would need a function that runs tonumber on every argument passed. NO_TYPICAL \u00b6 A function to be passed to _type or _tableof that disables lua-typical behavior with the guards.","title":"guardia.guards"},{"location":"module/guardia.guards/#guardiaguards","text":"Set of guards that come with Gu\u00e0rdia. Batteries included! Importing _ < type > from this module will return a type guard for < type > . Importing _not_ < type > from this module will return a negated type guard for < type > .","title":"guardia.guards"},{"location":"module/guardia.guards/#95type","text":"Signature \u2192 ( string , [ function ] ) -> (...) -> boolean , ... Type-checking source guard. Has to be manually finalized with _ps .","title":"_type"},{"location":"module/guardia.guards/#95tableof","text":"Signature \u2192 ( string , [ function ] ) -> (...) -> boolean , ... Guard that checks that all elements of a table are of the same type.","title":"_tableof"},{"location":"module/guardia.guards/#95tostring","text":"Signature \u2192 ( boolean , ...) -> -> boolean , ... tostring transformer guard. Warn Since it uses native tostring as the transformer function, it only supports conversion of one argument, so you would need a function that runs tostring on every argument passed.","title":"_tostring"},{"location":"module/guardia.guards/#95tonumber","text":"Signature \u2192 ( boolean , ...) -> -> boolean , ... tonumber transformer guard. Warn Since it uses native tonumber as the transformer function, it only supports conversion of one argument, so you would need a function that runs tonumber on every argument passed.","title":"_tonumber"},{"location":"module/guardia.guards/#no_typical","text":"A function to be passed to _type or _tableof that disables lua-typical behavior with the guards.","title":"NO_TYPICAL"},{"location":"module/guardia.init/","text":"guardia.init \u00b6 Guards for Lua. Based upon guard.lua . This version is rather thought for curried functions and use with MoonScript. Sources \u00b6 Sources are functions that take a set of values and start a guard chain. They're always of the kind (...) -> boolean , ... . _filter \u00b6 Signature \u2192 ( function ) -> (...) -> boolean , ... Alias \u2192 _fl Filtering function. If the filter passes, the first returned value is true , false otherwise. _true \u00b6 Signature \u2192 (...) -> boolean , ... Alias \u2192 _t Starts a chain, always returning true . _false \u00b6 Signature \u2192 (...) -> boolean , ... Alias \u2192 _f Starts a chain, always returning false . _default \u00b6 Signature \u2192 ( v ) -> (...) -> boolean , ... Alias \u2192 _df Makes the value of the chain a only if the first argument is nil . Transformers \u00b6 Transformers are functions which continue a chain, also modifying the arguments that go along with the boolean. They're always of the kind ( boolean , ...) -> boolean , ... . _transform \u00b6 Signature \u2192 ( function ) -> ( boolean , ...) -> boolean , ... Alias \u2192 _tr Transforms the values being passed through a function, only if the boolean passed is true . _negate \u00b6 Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _ng Negates the status from last operation. _error \u00b6 Signature \u2192 ( msg : string ) -> ( boolean , ...) -> false , ... Alias \u2192 _er Raises \u2192 Error message passed to the function (if boolean is true ). Errors with msg if the status is true . _e1 \u00b6 Signature \u2192 ( boolean , ...) -> false , ... Raises \u2192 \"guardia $ chain was stopped\" Predefined error for _error . _inspect \u00b6 Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _in Prints an inspect count number and every value on the chain, including the boolean. _named \u00b6 Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _ci Complex inspect. Instead of the inspect count number, prints the message along with every value on the chain and the status. Finalizers \u00b6 Finalizers are functions that end a guard chain, returning only part of the values. Their form can either be ( boolean , ...) -> boolean or ( boolean , ...) -> ... . _pass \u00b6 Signature \u2192 ( boolean , ...) -> ... Alias \u2192 _ps , _fn Ignores the boolean and returns the varargs. _status \u00b6 Signature \u2192 ( boolean , ...) -> boolean Alias \u2192 _st Returns the status from the chain and nothing else. Logic operators \u00b6 Basically wrappers that allow you to OR, AND, XOR, etc. various sources. These technically count as sources. _or \u00b6 Signature \u2192 ( function ) -> ( function ) -> function ORs two sources. _or1 \u00b6 Signature \u2192 ( function , function ) -> function Uncurried _or . _and \u00b6 Signature \u2192 ( function ) -> ( function ) -> function ANDs two sources. _and1 \u00b6 Signature \u2192 ( function , function ) -> function Uncurried _and . _xor \u00b6 Signature \u2192 ( function ) -> ( function ) -> function XORs two sources. _xor1 \u00b6 Signature \u2192 ( function , function ) -> function Uncurried _xor . v1 Guards \u00b6 These guards are v1 replicas made using the new guard functions. They are the closest to the original guard . lua . Most of them take the form ( function ) -> ( function ) -> ( function ) -> (...) -> ... . Guard \u00b6 Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... Uses a filter and transformer function on a set of values passed to f . Antiguard \u00b6 Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... Equivalent to Guard , but negates the results of fl . Biguard \u00b6 Signature \u2192 ( fl : function ) -> ( tr : function , ar : function ) -> ( f : function ) -> (...) -> ... Essentially a mix of Guard and Antiguard , so the transformer tr runs when the filter passes, ar otherwise. Endguard \u00b6 Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... A guard for the result values of the function f called with ... . Errguard \u00b6 Guard but errors if the filter does not pass. Enderrguard \u00b6 Endguard but errors if the filter does not pass. Antierrguard \u00b6 Antiguard but errors if the filter does not pass.","title":"guardia.init"},{"location":"module/guardia.init/#guardiainit","text":"Guards for Lua. Based upon guard.lua . This version is rather thought for curried functions and use with MoonScript.","title":"guardia.init"},{"location":"module/guardia.init/#sources","text":"Sources are functions that take a set of values and start a guard chain. They're always of the kind (...) -> boolean , ... .","title":"Sources"},{"location":"module/guardia.init/#95filter","text":"Signature \u2192 ( function ) -> (...) -> boolean , ... Alias \u2192 _fl Filtering function. If the filter passes, the first returned value is true , false otherwise.","title":"_filter"},{"location":"module/guardia.init/#95true","text":"Signature \u2192 (...) -> boolean , ... Alias \u2192 _t Starts a chain, always returning true .","title":"_true"},{"location":"module/guardia.init/#95false","text":"Signature \u2192 (...) -> boolean , ... Alias \u2192 _f Starts a chain, always returning false .","title":"_false"},{"location":"module/guardia.init/#95default","text":"Signature \u2192 ( v ) -> (...) -> boolean , ... Alias \u2192 _df Makes the value of the chain a only if the first argument is nil .","title":"_default"},{"location":"module/guardia.init/#transformers","text":"Transformers are functions which continue a chain, also modifying the arguments that go along with the boolean. They're always of the kind ( boolean , ...) -> boolean , ... .","title":"Transformers"},{"location":"module/guardia.init/#95transform","text":"Signature \u2192 ( function ) -> ( boolean , ...) -> boolean , ... Alias \u2192 _tr Transforms the values being passed through a function, only if the boolean passed is true .","title":"_transform"},{"location":"module/guardia.init/#95negate","text":"Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _ng Negates the status from last operation.","title":"_negate"},{"location":"module/guardia.init/#95error","text":"Signature \u2192 ( msg : string ) -> ( boolean , ...) -> false , ... Alias \u2192 _er Raises \u2192 Error message passed to the function (if boolean is true ). Errors with msg if the status is true .","title":"_error"},{"location":"module/guardia.init/#95e1","text":"Signature \u2192 ( boolean , ...) -> false , ... Raises \u2192 \"guardia $ chain was stopped\" Predefined error for _error .","title":"_e1"},{"location":"module/guardia.init/#95inspect","text":"Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _in Prints an inspect count number and every value on the chain, including the boolean.","title":"_inspect"},{"location":"module/guardia.init/#95named","text":"Signature \u2192 ( boolean , ...) -> boolean , ... Alias \u2192 _ci Complex inspect. Instead of the inspect count number, prints the message along with every value on the chain and the status.","title":"_named"},{"location":"module/guardia.init/#finalizers","text":"Finalizers are functions that end a guard chain, returning only part of the values. Their form can either be ( boolean , ...) -> boolean or ( boolean , ...) -> ... .","title":"Finalizers"},{"location":"module/guardia.init/#95pass","text":"Signature \u2192 ( boolean , ...) -> ... Alias \u2192 _ps , _fn Ignores the boolean and returns the varargs.","title":"_pass"},{"location":"module/guardia.init/#95status","text":"Signature \u2192 ( boolean , ...) -> boolean Alias \u2192 _st Returns the status from the chain and nothing else.","title":"_status"},{"location":"module/guardia.init/#logic-operators","text":"Basically wrappers that allow you to OR, AND, XOR, etc. various sources. These technically count as sources.","title":"Logic operators"},{"location":"module/guardia.init/#95or","text":"Signature \u2192 ( function ) -> ( function ) -> function ORs two sources.","title":"_or"},{"location":"module/guardia.init/#95or1","text":"Signature \u2192 ( function , function ) -> function Uncurried _or .","title":"_or1"},{"location":"module/guardia.init/#95and","text":"Signature \u2192 ( function ) -> ( function ) -> function ANDs two sources.","title":"_and"},{"location":"module/guardia.init/#95and1","text":"Signature \u2192 ( function , function ) -> function Uncurried _and .","title":"_and1"},{"location":"module/guardia.init/#95xor","text":"Signature \u2192 ( function ) -> ( function ) -> function XORs two sources.","title":"_xor"},{"location":"module/guardia.init/#95xor1","text":"Signature \u2192 ( function , function ) -> function Uncurried _xor .","title":"_xor1"},{"location":"module/guardia.init/#v1-guards","text":"These guards are v1 replicas made using the new guard functions. They are the closest to the original guard . lua . Most of them take the form ( function ) -> ( function ) -> ( function ) -> (...) -> ... .","title":"v1 Guards"},{"location":"module/guardia.init/#guard","text":"Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... Uses a filter and transformer function on a set of values passed to f .","title":"Guard"},{"location":"module/guardia.init/#antiguard","text":"Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... Equivalent to Guard , but negates the results of fl .","title":"Antiguard"},{"location":"module/guardia.init/#biguard","text":"Signature \u2192 ( fl : function ) -> ( tr : function , ar : function ) -> ( f : function ) -> (...) -> ... Essentially a mix of Guard and Antiguard , so the transformer tr runs when the filter passes, ar otherwise.","title":"Biguard"},{"location":"module/guardia.init/#endguard","text":"Signature \u2192 ( fl : function ) -> ( tr : function ) -> ( f : function ) -> (...) -> ... A guard for the result values of the function f called with ... .","title":"Endguard"},{"location":"module/guardia.init/#errguard","text":"Guard but errors if the filter does not pass.","title":"Errguard"},{"location":"module/guardia.init/#enderrguard","text":"Endguard but errors if the filter does not pass.","title":"Enderrguard"},{"location":"module/guardia.init/#antierrguard","text":"Antiguard but errors if the filter does not pass.","title":"Antierrguard"}]}